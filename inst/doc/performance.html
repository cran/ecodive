<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Performance Guide</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Performance Guide</h1>



<div id="optimizing-ecodive-for-large-datasets" class="section level2">
<h2>Optimizing <code>ecodive</code> for Large Datasets</h2>
<p><code>ecodive</code> is engineered for high performance, using
parallelized C code to deliver results quickly and with minimal memory
usage. For most use cases, you can pass your data in any standard R
format (like a <code>matrix</code> or <code>data.frame</code>) and get
fast results.</p>
<p>However, when working with very large datasets—such as those with
thousands of samples or hundreds of thousands of features—you can
achieve noticeably better performance by paying attention to the format
of your input data. These optimizations minimize the internal data
conversion steps that <code>ecodive</code> has to perform.</p>
<div id="the-optimal-input-compressed-sparse-matrices" class="section level3">
<h3>The Optimal Input: Compressed Sparse Matrices</h3>
<p><code>ecodive</code> is highly efficient at reformatting data
internally for one-off calculations. You do not need to manually format
your data for single function calls.</p>
<p>However, if you plan to run <strong>multiple <code>ecodive</code>
functions</strong> on the same large dataset, you will see a performance
benefit by converting your data into the optimal format first. This
format is a <strong>column-compressed sparse matrix
(<code>dgCMatrix</code>)</strong> from the <code>Matrix</code> package,
with <strong>samples arranged in columns</strong>.</p>
<p>By doing the conversion once, you prevent <code>ecodive</code> from
having to reformat the data for each subsequent function call.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(ecodive)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(Matrix)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># Assume &#39;my_counts&#39; is a standard matrix with samples in rows</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>my_counts <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(ex_counts)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># Convert once to the optimal format</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>optimal_counts <span class="ot">&lt;-</span> <span class="fu">as</span>(<span class="fu">t</span>(my_counts), <span class="st">&quot;dgCMatrix&quot;</span>)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co"># Now, run multiple analyses on the pre-formatted object.</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co"># Remember to specify margin = 2L since samples are in columns.</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>shannon_vals <span class="ot">&lt;-</span> <span class="fu">shannon</span>(optimal_counts, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>simpson_vals <span class="ot">&lt;-</span> <span class="fu">simpson</span>(optimal_counts, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>observed_vals <span class="ot">&lt;-</span> <span class="fu">observed</span>(optimal_counts, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span></code></pre></div>
<div id="why-sparse-matrices" class="section level4">
<h4>Why Sparse Matrices?</h4>
<p>Ecological datasets, particularly from amplicon sequencing (16S, ITS)
or shotgun metagenomics, are typically “sparse.” This means that for any
given sample, the vast majority of species in the full dataset have a
count of zero.</p>
<p>A standard R <code>matrix</code> stores every single value, including
all the zeros. For a large dataset, this can consume a massive amount of
memory. A sparse matrix, on the other hand, only stores the non-zero
values and their locations. This dramatically reduces the memory
footprint.</p>
<p>By providing a <code>dgCMatrix</code> with samples in columns, you
are feeding <code>ecodive</code> data in its preferred native format,
allowing it to skip any internal conversion and proceed directly to
calculations.</p>
</div>
<div id="rbiom-users" class="section level4">
<h4><code>rbiom</code> Users</h4>
<p>If you use the <code>rbiom</code> package to manage your data, you’re
already taking advantage of this! <code>rbiom</code> objects store their
count tables internally as a <code>dgCMatrix</code> with samples in
columns. When you pass an <code>rbiom</code> object to an
<code>ecodive</code> function, it is passed in this optimal format
automatically.</p>
</div>
</div>
<div id="handling-data-transformations" class="section level3">
<h3>Handling Data Transformations</h3>
<p>Many diversity metrics operate on transformed data, most commonly
relative abundances (<code>norm = &#39;percent&#39;</code>). When you specify a
transformation like <code>norm = &#39;percent&#39;</code>, <code>ecodive</code>
performs this conversion internally. This adds a small amount of
computational overhead.</p>
<p>If you plan to run many different analyses on the same transformed
data, it is more efficient to perform the transformation once yourself
and then pass the pre-transformed data to <code>ecodive</code>,
specifying <code>norm = &#39;none&#39;</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Inefficient: Transforming the data twice</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>shannon_vals <span class="ot">&lt;-</span> <span class="fu">shannon</span>(optimal_counts, <span class="at">norm =</span> <span class="st">&#39;percent&#39;</span>, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>simpson_vals <span class="ot">&lt;-</span> <span class="fu">simpson</span>(optimal_counts, <span class="at">norm =</span> <span class="st">&#39;percent&#39;</span>, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co"># More Efficient: Transform once</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>rel_abund <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">apply</span>(<span class="fu">t</span>(optimal_counts), <span class="dv">1</span>, <span class="cf">function</span>(x) x <span class="sc">/</span> <span class="fu">sum</span>(x)))</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>rel_abund <span class="ot">&lt;-</span> <span class="fu">as</span>(rel_abund, <span class="st">&quot;dgCMatrix&quot;</span>)</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>shannon_vals <span class="ot">&lt;-</span> <span class="fu">shannon</span>(rel_abund, <span class="at">norm =</span> <span class="st">&#39;none&#39;</span>, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>simpson_vals <span class="ot">&lt;-</span> <span class="fu">simpson</span>(rel_abund, <span class="at">norm =</span> <span class="st">&#39;none&#39;</span>, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span></code></pre></div>
<div id="the-exception-centered-log-ratio-clr" class="section level4">
<h4>The Exception: Centered Log-Ratio (CLR)</h4>
<p>The one exception to this rule is the centered log-ratio
transformation (<code>norm = &#39;clr&#39;</code>), used for calculating
Aitchison distance. A standard CLR transformation turns a sparse matrix
into a “dense” matrix (where all zeros become non-zero values), which
dramatically increases memory consumption.</p>
<p><code>ecodive</code>’s internal CLR implementation uses special
techniques to calculate the result while preserving the sparse matrix
structure as much as possible. Therefore, for CLR-based metrics, you
will achieve better performance and lower memory usage by letting
<code>ecodive</code> handle the transformation.</p>
<p><strong>Do this:</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Best for CLR: Let ecodive handle the transformation</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>aitchison_dist <span class="ot">&lt;-</span> <span class="fu">aitchison</span>(optimal_counts, <span class="at">margin =</span> <span class="dv">2</span><span class="dt">L</span>)</span></code></pre></div>
<p><strong>Not this:</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Inefficient for CLR: Pre-transforming creates a dense matrix</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">library</span>(compositions)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>dense_matrix <span class="ot">&lt;-</span> <span class="fu">clr</span>(<span class="fu">t</span>(<span class="fu">as.matrix</span>(optimal_counts)) <span class="sc">+</span> <span class="dv">1</span>) <span class="co"># Becomes dense</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>aitchison_dist <span class="ot">&lt;-</span> <span class="fu">euclidean</span>(dense_matrix, <span class="at">norm =</span> <span class="st">&#39;none&#39;</span>)</span></code></pre></div>
</div>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>For the best performance with <strong>very large
datasets</strong>:</p>
<ol style="list-style-type: decimal">
<li>Store your count data as a <code>dgCMatrix</code> with samples in
columns.</li>
<li>Use <code>margin = 2L</code> in <code>ecodive</code> function
calls.</li>
<li>For repeated calculations, pre-transform your data (e.g., to
relative abundance) and use <code>norm = &#39;none&#39;</code>.</li>
<li><strong>Exception</strong>: Always let <code>ecodive</code> handle
CLR transformations by using <code>norm=&#39;clr&#39;</code>.</li>
</ol>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
